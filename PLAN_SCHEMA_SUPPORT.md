# План внедрения поддержки опции `schema` для динамической опции `consists_of`

## Ограничения
- **Нельзя изменять работу класса `DynamicOptions::ConsistsOf` и опцию `consists_of` — даже если это потребуется для реализации поддержки `schema` для коллекций. Вся новая логика должна быть реализована только в рамках доработки класса `DynamicOptions::Schema` и опции `schema`.**

## Цель
Добавить поддержку опции `schema` для атрибутов с типом `Array` и `consists_of: Hash`, чтобы можно было валидировать структуру каждого элемента массива по заданной схеме.

## Этапы

### 1. Анализ текущей реализации
- Изучить класс `Schema` и понять, где происходит валидация структуры хеша.
- Убедиться, что текущая логика не нарушится при добавлении новой поддержки коллекций.

### 2. Анализ примеров
- Изучить примеры использования `schema` в `examples/usual/dynamic_options/schema`.
- Зафиксировать все кейсы, которые должны остаться рабочими.

### 3. Проектирование поддержки коллекций
- Опция `schema` должна работать для атрибутов с типом `Array` (или Set), если элементы коллекции — Hash.
- Для каждого элемента массива, если он Hash, должна выполняться валидация по схеме.
- Схема задается в виде хеша: `{ ключ: { type: ..., required: ... }, ... }`.
- Валидация должна проверять:
  - Наличие обязательных ключей (`required: true`).
  - Соответствие типа значения ключа (`type: ...`).
  - Для вложенных хешей — рекурсивно по вложенной схеме.
  - Возможность указания значения по умолчанию (`default`) для необязательных ключей.

### 4. Изменения в коде
- В классе `Schema`:
  - Добавить обработку коллекций (Array/Set) с элементами Hash.
  - Реализовать валидацию каждого элемента коллекции по схеме.
  - Не нарушать текущую логику для других типов и опций.
- Добавить/обновить сообщения об ошибках для schema.

### 5. Примеры
- Добавить примеры использования новой поддержки коллекций в `examples/usual/dynamic_options/schema`.
- Пример:
  ```ruby
  input :items, type: Array, schema: {
    id: { type: String, required: true },
    name: { type: String, required: true }
  }
  ```

### 6. Тесты
- Добавить/обновить тесты для проверки новой функциональности schema для коллекций.
- Проверить, что не нарушен существующий функционал.
- **Все тесты для новой функциональности должны быть написаны строго в таком же формате и стиле, как существующие тесты в `spec/examples/usual/dynamic_options/schema`: использовать RSpec, describe/it, shared_examples, проверки ошибок и сообщений, структуру входных данных и атрибутов аналогично существующим тестам.**

### 7. Рефакторинг и проверка
- Провести рефакторинг, если потребуется.
- Убедиться, что весь функционал работает корректно и обратная совместимость сохранена.

---

### Как работает опция `schema` (справочно)

- Опция `schema` используется для валидации структуры хеша (`Hash`) в качестве значения атрибута (`input`, `internal`, `output`).
- Схема (`schema`) задаётся в виде хеша, где для каждого ключа указывается ожидаемый тип (`type`) и обязательность (`required`). Также можно указывать вложенные схемы для вложенных хешей.
- Валидация по схеме проверяет:
  - Наличие обязательных ключей (`required: true`).
  - Соответствие типа значения ключа (`type: ...`).
  - Для вложенных хешей — рекурсивно по вложенной схеме.
  - Возможность указания значения по умолчанию (`default`) для необязательных ключей.
- Схема может быть вынесена в константу и переиспользована для разных атрибутов (input, internal, output).
- Примеры показывают, что схема может быть глубоко вложенной и поддерживает сложные структуры данных.

Пример:
```ruby
input :payload, type: Hash, schema: {
  request_id: { type: String, required: true },
  user: {
    type: Hash,
    required: true,
    first_name: { type: String, required: true },
    # ... и так далее, включая вложенные хэши
  }
}
```

**После выполнения всех этапов — задача считается завершённой.** 